import { html, render } from '../lit-html/lib/lit-extended.js';
export { html } from '../lit-html/lib/lit-extended.js';
export class LitElement extends HTMLElement {
    constructor() {
        super();
        this._needsRender = false;
        this._lookupCache = [];
        this._values = [];
        this._attrMap = {};
        this._deps = {};
        this._resolved = false;
        this.attachShadow({ mode: 'open' });
        for (const propertyName in this.constructor.properties) {
            const { value, attrName, computed } = this.constructor.properties[propertyName];
            // We can only handle properly defined attributes.
            if (typeof (attrName) === 'string' && attrName.length) {
                this._attrMap[attrName] = propertyName;
            }
            // Properties backed by attributes have default values set from attributes, not 'value'.
            if (!attrName && value !== undefined) {
                this[propertyName] = value;
            }
            // Only property defined 'computes' are handled of form 'firstName(name, surname)',
            // with at least one dependency argument.
            const match = /(\w+)\((.+)\)/.exec(computed);
            if (!attrName && match) {
                const fnName = match[1];
                const argNames = match[2].split(/,\s*/);
                const boundFn = () => this[propertyName] = this[fnName].apply(this, argNames.map(argName => this[argName]));
                let hasAtLeastOneValue = false;
                for (const argName of argNames) {
                    hasAtLeastOneValue = hasAtLeastOneValue || this[argName] !== undefined;
                    if (!this._deps[argName]) {
                        this._deps[argName] = [boundFn];
                    }
                    else {
                        this._deps[argName].push(boundFn);
                    }
                }
                if (hasAtLeastOneValue) {
                    boundFn();
                }
            }
        }
    }
    _setPropertyValue(propertyName, newValue) {
        this._values[propertyName] = newValue;
        if (this._deps[propertyName]) {
            this._deps[propertyName].map((fn) => fn());
        }
    }
    _setPropertyValueFromAttributeValue(attrName, newValue) {
        const propertyName = this._attrMap[attrName];
        const { type: typeFn } = this.constructor.properties[propertyName];
        let value;
        if (typeFn.name === 'Boolean') {
            console.log(attrName + ": " + newValue);
            value = (newValue === '') || (!!newValue && newValue === attrName.toLowerCase());
        }
        else {
            value = (newValue !== null) ? typeFn(newValue) : null;
        }
        this._setPropertyValue(propertyName, value);
    }
    static get properties() {
        return [];
    }
    static get observedAttributes() {
        return Object.keys(this.properties)
            .map(key => this.properties[key].attrName)
            .filter(name => name);
    }
    static withProperties() {
        for (const propertyName in this.properties) {
            const { type: typeFn, attrName } = this.properties[propertyName];
            Object.defineProperty(this.prototype, propertyName, {
                get() { return this._values[propertyName]; },
                set(v) {
                    const value = typeFn === Array ? v : typeFn(v);
                    this._setPropertyValue(propertyName, value);
                    if (attrName) {
                        if (typeFn.name === 'Boolean') {
                            if (!value) {
                                this.removeAttribute(attrName);
                            }
                            else {
                                this.setAttribute(attrName, attrName);
                            }
                        }
                        else {
                            this.setAttribute(attrName, value);
                        }
                    }
                    this.invalidate();
                },
            });
        }
        return this;
    }
    renderCallback() {
        if (this._resolved) {
            render(this.render(this), this.shadowRoot);
        }
        else {
            const template = this.render(this).template;
            const rootNode = template.element.content;
            const walker = document.createTreeWalker(rootNode, NodeFilter.SHOW_ELEMENT, null, false);
            const deps = new Set();
            while (walker.nextNode()) {
                const element = walker.currentNode;
                if (element.tagName.includes('-')) {
                    deps.add(element.tagName.toLowerCase());
                }
            }
            Promise.all(Array.from(deps)
                .map(tagName => customElements.whenDefined(tagName)))
                .then(() => {
                this._resolved = true;
                this.renderCallback();
            });
        }
    }
    // @ts-ignore
    render(self) {
        return html ``;
    }
    attributeChangedCallback(attrName, _oldValue, newValue) {
        this._setPropertyValueFromAttributeValue(attrName, newValue);
        this.invalidate();
    }
    connectedCallback() {
        for (const attrName of this.constructor.observedAttributes) {
            this._setPropertyValueFromAttributeValue(attrName, this.getAttribute(attrName));
        }
        this.invalidate();
    }
    async invalidate() {
        if (!this._needsRender) {
            this._needsRender = true;
            // Schedule the following as micro task, which runs before
            // requestAnimationFrame. All additional invalidate() calls
            // before will be ignored.
            // https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
            this._needsRender = await false;
            this.renderCallback();
        }
    }
    $(id) {
        let value = this._lookupCache[id];
        if (!value && this.shadowRoot) {
            const element = this.shadowRoot.getElementById(id);
            if (element) {
                value = element;
                this._lookupCache[id] = element;
            }
        }
        return value;
    }
}
//# sourceMappingURL=lit-element.js.map